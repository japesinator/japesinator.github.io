<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<title> On Set </title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

		<div id="container">

			<div class="left">
				<h1>JP Writes Code</h1>
				<img id="about" src="/img/logo.png" height="75px" width="75px" /><br />	

				<strong>navigation</strong><br />
				<a href="/">home</a> <br />
				
					<a class="about" href="https://github.com/japesinator">github</a><br />
				
					<a class="about" href="mailto:jp@writes.co.de">email</a><br />
				
					<a class="about" href="https://twitter.com/japesinator">twitter</a><br />
				
					<a class="about" href="/about">about</a><br />
				
				
				
				<div id="about">
					<strong>about</strong><br />
					I am a high school student in the midwest who likes math, computers, and other interesting things
				</div>
				
			</div>

			<div class="right">
				
				<h1>On Set</h1>
<span class="time">23 Jan 2014</span>

<div class="content">
	<div class="post"><h1>On Set</h1>

<p>For those not familiar, <a href="https://en.wikipedia.org/wiki/Set_%28game%29">Set</a> is a relatively simple board game played in real time by assembling &quot;sets&quot; of cards.  Each card in the game has four attributes (shape, color, number, and filling) which can each be any of three different values ((oval, squiggle, or diamond), (red, blue, or green), (one, two, or three), and (empty, shaded, or full), respectively).  A &quot;set&quot; is only valid if for each attribute, each of the three cards in the set either has the same value or no two cards have the same value.  For instance, one solid red diamond, two shaded blue ovals, and three empty green squiggles would make a set because no two cards share an attribute.  One solid red oval, two solid red ovals, and three solid red ovals are also a set because they all have the same filling, color, and shape, but they all have a different number.  In general, a set has no <em>pairs</em> of attributes, just triplets or uniques.</p>

<p>For this reason, cards lend themselves to representation as a four-element array of ternary values representing their attributes.  For instance, a 0 in the first element of the array could mean oval, a 1 diamond, and a 2 squiggle.  The only question is whether to use standard ternary or <a href="https://en.wikipedia.org/wiki/Balanced_ternary">balanced ternary</a>.  While balanced ternary has a number of computational advantages, for our purposes, standard 0-1-2 ternary actually allows us some computational shortcuts.  Firstly, a function to find out whether a given triplet of cards is a set, which would normally be horrendously ugly and check for any possible pair of matching values with no triplet can instead be written as below.  Note that the sum function, which cleans up the code a bit, would not always work with balanced ternary.</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="lineno">1</span> <span class="nf">is_set</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="lineno">2</span> 
<span class="lineno">3</span> <span class="nf">is_set</span> <span class="n">card0</span> <span class="n">card1</span> <span class="n">card2</span>
<span class="lineno">4</span>   <span class="o">|</span> <span class="n">sum</span> <span class="p">(</span><span class="n">map</span> <span class="p">(`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="n">zipWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">card0</span> <span class="p">(</span><span class="n">zipWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">card1</span> <span class="n">card2</span><span class="p">)))</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kt">True</span>
<span class="lineno">5</span>   <span class="c1">-- First we sum the numbers in each card mod 3, and then we sum the numbers in that array</span>
<span class="lineno">6</span>   <span class="c1">-- This can only result in zero if the array is [0,0,0,0]</span>
<span class="lineno">7</span>   <span class="o">|</span> <span class="n">otherwise</span>                                                              <span class="ow">=</span> <span class="kt">False</span></code></pre></div>

<p>The above code hardly does anything to help the stereotype of Haskell as unreadable, but with a little analysis it is both clear and elegant.  Given three lists, it creates a new list where each element is the sum of the elements in the same place in the original list modulo three, then checks if that list is entirely zeroes by summing it. So given [a,b,c,d], [e,f,g,h], and [i,j,k,l], if (a + e + i) % 3 + (b + f + j) % 3 + (c + g + k) % 3 + (d + h + l) % 3 == 0, it returns true.  Otherwise, it returns false.  This works because 3n % 3 == 0 while n is any number and (0 + 1 + 2) % 3 == 0, but (2n + m) % 3 != 0 while 0 &lt;= n, m &lt;= 2.</p>

<p>Another interesting problem is the number of total sets.  This can be approached from a number of different ways.  Perhaps the most intuitive is by looking at the number of possible sets in a game with only one attribute, a game with only two attributes, and so on onto a game of four attributes.  While perhaps the most mathematically &quot;pure&quot; method, this is also challenging and an unnecessary amount of work.  Instead, we can rely on the modulo arithmetic discussed above.  Since a set is only valid when the sum mod 3 of its attributes represented numerically is 0, given two attributes we can deduce the value of the third necessary to complete the set.  There will also be only one value between zero and two that works, so a pair of attributes implies a unique third to have a valid set.  This means that any pair of cards implies a unique third card that completes a set with them.</p>

<p>The naive interpretation of this is that the number of possible sets is equal to the number of possible pairs, but that forgets that a group of three cards contains three different pairs ((0,1), (1,2), (0,2)), and that each pair can be revealed one of two ways.  Thus, the number of possible sets is equal to the number of possible pairs divided by three times two.  Since there are 81 cards, the total number of possible sets is (81 * 80) / (3 * 2), which is the same as (27 * 40), which is 1080.  This also means that drawing two cards off of a fresh deck, there is only one card in the deck that forms a set with them, so the odds that three random cards form a set is one over the number of cards in the deck minus two, or 1/79.  Wikipedia confirms these numbers if not the reasoning behind them.  This even solves our earlier problem about the number of possible sets in a game with n attributes, because the only thing in our math that changes with a different number of attributes is the deck size, which is now equal to 3^n.  Thus, the number of possible sets in a game with n attributes, assuming there is exactly one card for every combination of attributes, is (3^n * (3^n -1)) / (6), which simplifies to (3^(2n -1) - 3^(n-1)) / 2.</p>

<p>Also interesting is the actual playing of set.  If we want to write a program to analyze an array of cards and select sets from it, we have an huge selection of options.  Perhaps the most tempting is just to create a list comprehension that looks at every triplet of cards and checks if it is a valid set.  This would be easy to implement, but would have something like O(n^3) runtime because it runs its large, complex operation for every possible triple of cards, which, if there are n cards, means that it runs (n)(n-1)(n-2) times.  Reducing the runtime significantly below that is hard, because we fundamentally working with all possible triples (Assuming we don&#39;t just use some massive hash table of all possible groups of cards), and this lends itself heavily to what is essentially a triple nested loop, but we can optimize a lot by instead looking at every pair of cards, computing the third card necessary, and searching for it.  Code to do that is shown below.</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="lineno">1</span> <span class="nf">get_third_card</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="lineno">2</span> 
<span class="lineno">3</span> <span class="nf">get_third_card</span> <span class="n">card0</span> <span class="n">card1</span> <span class="ow">=</span> <span class="n">zipWith</span> <span class="p">(</span><span class="o">-</span><span class="p">)</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">(</span><span class="n">map</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">3</span> <span class="p">(</span><span class="n">zipWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">card0</span> <span class="n">card1</span><span class="p">))</span></code></pre></div>

<p>This is an improvement because the computationally expensive step is only performed a bit less than n^2 times, while the computationally cheap comparison takes up the rest of the cycles.  Working this into actual code, we can see an improvement of almost n - 2 times, where n is the number of cards we are analyzing.  Below is a four-line program to get a set from a given group of cards.</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="lineno">1</span> <span class="nf">cards</span> <span class="ow">=</span> <span class="p">[</span><span class="n">a</span> <span class="n">bunch</span> <span class="kr">of</span> <span class="n">four</span><span class="o">-</span><span class="n">element</span> <span class="n">arrays</span><span class="p">]</span>
<span class="lineno">2</span> 
<span class="lineno">3</span> <span class="nf">get_third_card</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="lineno">4</span> <span class="c1">-- This is just a type definition.  It&#39;s a bit like declaring variables with types is a C like language.</span>
<span class="lineno">5</span> <span class="nf">get_third_card</span> <span class="n">card0</span> <span class="n">card1</span> <span class="ow">=</span> <span class="n">zipWith</span> <span class="p">(</span><span class="o">-</span><span class="p">)</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">(</span><span class="n">map</span> <span class="p">(`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="n">zipWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">card0</span> <span class="n">card1</span><span class="p">))</span>
<span class="lineno">6</span> <span class="c1">-- The third card will sum with the first two to [0, 0, 0, 0] mod 3, see code above for why</span>
<span class="lineno">7</span> <span class="nf">set</span>  <span class="ow">=</span> <span class="n">head</span> <span class="p">[</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">|</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">cards</span><span class="p">,</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">cards</span><span class="p">,</span> <span class="n">c</span> <span class="ow">&lt;-</span> <span class="n">cards</span><span class="p">,</span> <span class="n">get_third_card</span> <span class="n">a</span> <span class="n">b</span> <span class="o">==</span> <span class="n">c</span><span class="p">]</span>
<span class="lineno">8</span> <span class="c1">-- The set found is just the first from the list of valid sets.</span></code></pre></div>

<p>One of the reasons I love Haskell is that it&#39;s possible to write an AI for a complex board game in four relatively simple lines of code, and that the way the algorithm plays set is more or less the same way I do.</p>
</div>
</div>

				
				<footer>
					 
            <p>JP Smith made this</p>
					
				</footer>
			</div>
		
		</div>

    </body>
</html>
