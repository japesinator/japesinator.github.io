<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<title> Types as Tests </title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

		<div id="container">

			<div class="left">
				<h1>JP Writes Code</h1>
				<img id="about" src="/img/logo.png" height="75px" width="75px" /><br />	

				<strong>navigation</strong><br />
				<a href="/">home</a> <br />
				
					<a class="about" href="https://github.com/japesinator">github</a><br />
				
					<a class="about" href="mailto:jp.smith@ilstu.edu">email</a><br />
				
					<a class="about" href="/about">about</a><br />
				
				
				
				<div id="about">
					<strong>about</strong><br />
					I am a high school student in the midwest who likes math, computers, and other interesting things
				</div>
				
			</div>

			<div class="right">
				
				<h1>Types as Tests</h1>
<span class="time">03 Oct 2014</span>

<div class="content">
	<div class="post"><h1>Types as Tests</h1>

<p>Recently, a fried of mine were going over the ages old tests vs. types debate.  Specifically, if a programmer wants to have some degree of certainty that their program will function as intended, does it work better to use unit testing or static typing?  However, the more I looked at the argument we were having, the less it made sense to me as a strict dichotomy.  Obviously, best practices for ensuring Python code works as intended are different from ensuring Haskell code works as intended, and you&#39;ll catch some bugs with Python best practices that you won&#39;t catch with Haskell best practices and vice versa, but in a sufficiently advanced language, assertions about the code are the same as function types and vice versa.</p>

<p>For instance, consider the (rather trivial) example of a function that reverses lists.  In python:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python">def reverse(list):
  return list[::-1]</code></pre></div>

<p>In Idris</p>

<div class="highlight"><pre><code class="language-idris" data-lang="idris">reverse : List a -&gt; List a
reverse = reverse&#39; []
  where
    reverse&#39; : List a -&gt; List a -&gt; List a
    reverse&#39; acc [] = acc
    reverse&#39; acc (x::xs) = reverse&#39; (x::acc) xs</code></pre></div>

<p>Suppose we want to show that an example list reversed twice is itself.  In Python, we might try an assertion.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python">import unittest

testVar = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

assert testVar == reverse(reverse(testVar))</code></pre></div>

<p>If we were doing something more complex, we could use <a href="https://docs.python.org/2/library/unittest.html">unittest</a> or <a href="https://nose.readthedocs.org/en/latest/">nose</a> or any number of other options, but for the sake of simplicity, we&#39;ll stick with with <code>assert</code> for now.</p>

<p>Now we wish to make the same assertion about our idris function.</p>

<div class="highlight"><pre><code class="language-idris" data-lang="idris">testvar : List Int
testVar = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

reverseTwice : testvar = reverse $ reverse testvar
reverseTwice = refl</code></pre></div>

<p>Note that the assertion happens in the <em>type</em> of <code>reverseTwice</code>, not the definition like in the Python example, but the two serve the exact same purpose.  This is because an assertion is a proposition about a program, and a <a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">proposition is a type</a>, so any assertion can be written as the type of a variable, given sufficient tools to do so.  The definition of the variable with that type then, is the proof of the proposition the assertion makes in the first place.  Notably, this allows us to use relatively advanced tactics to make much more powerful assertions than in languages without this functionality.  For instance, <a href="http://sitr.us/2014/05/05/category-theory-proofs-in-idris.html">Jesse Hallett&#39;s category theory proofs</a>.</p>

<p>One concrete example would be <a href="https://github.com/defanor/idris-stuff/blob/master/Vect.idr">this rewrite of reverse</a> by defanor, that generalizes our earlier assertion to not just <code>testVar</code>, but any Vect.  Obviously, this is more work than a simple assert statement, but an assert statement is also more work than not testing at all, and for code that <em>really needs to work</em>, a proof that it always will work is often desirable.</p>

<p>Obviously, there are types of testing that can&#39;t be written as a type.  It&#39;s unlikely that <a href="http://www.seleniumhq.org/">selenium</a> can ever have a type-level equivalent, and something like <a href="https://github.com/nick8325/quickcheck">quickcheck</a> that uses stochastic methods to give a fuzzier guarantee is a fundamentally different tactic, but the vast majority of unit testing is equivalent to simple types.  Not only that, but dependent types and totality checking allow us to check every possible value for a parameter against its expected output all at once using mathematical reasoning.  And while there is certainly a place for assertions, dependent types make them seem as primitive as the goto when it comes to ensuring program correctness.</p>
</div>
</div>

				
				<footer>
					 
            <p>JP Smith made this</p>
					
				</footer>
			</div>
		
		</div>

    </body>
</html>
