<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
        <channel>
                <title>JP Writes Code</title>
                <description>Things I find interesting</description>
                <link>http://japesinator.github.io</link>
                <atom:link href="http://japesinator.github.io/feed.xml" rel="self" type="application/rss+xml" />
                
                        <item>
                                <title>Stacked Type Signatures</title>
                                <description>&lt;h1&gt;Stacked Type Signatures&lt;/h1&gt;

&lt;p&gt;In general, I greatly prefer programming in functional, strongly-typed languages.  I&amp;#39;m currently working on &lt;a href=&quot;https://github.com/Lopi/HackMan&quot;&gt;a project&lt;/a&gt; in &lt;a href=&quot;http://elm-lang.org/&quot;&gt;elm&lt;/a&gt;, &lt;a href=&quot;https://github.com/japesinator/tarts&quot;&gt;a project&lt;/a&gt; in &lt;a href=&quot;http://www.idris-lang.org/&quot;&gt;idris&lt;/a&gt; and a few miscellaneous odds and ends in Haskell.  In all of these languages, types are relatively important, and especially so in the style of programming I tend to prefer.&lt;/p&gt;

&lt;p&gt;In said functional, strongly-typed languages, type signatures are either best practices or required for functions.  The typical format of a type signature is something along the lines of:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Which is read &amp;quot;&lt;code&gt;map&lt;/code&gt; is a function from a function from something of type &lt;code&gt;a&lt;/code&gt; to something of type &lt;code&gt;b&lt;/code&gt; to a function from a list of type &lt;code&gt;a&lt;/code&gt; to a list of type &lt;code&gt;b&lt;/code&gt;&amp;quot;, or, to put it less completely unitelligibly, &lt;code&gt;map&lt;/code&gt; takes a function and a list of things that function can be applied to and returns a list of things of the same type as that function returns.  However, lately I&amp;#39;ve switched from the style above in writing my own type signatures to something more like:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;At first this seems totally unnecessary and waste-of-space-y, but I actually have grown to greatly prefer it over the standard style.  While for &lt;code&gt;map&lt;/code&gt; it doesn&amp;#39;t make a ton of difference, in more complex type signatures, I&amp;#39;ve found it makes both reading and documenting code much more intuitive, at least for me.  Consider the function &lt;code&gt;zipWith3&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;zipWith3&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Rewritten in stacked style:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;zipWith3&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Immediately, it seems a bit clearer, but now consider the well-commented version.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;zipWith3&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- The function to zip with&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;-- The first list to zip together&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;-- The second list to zip together&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;-- The third list to zip together&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;                   &lt;span class=&quot;c1&quot;&gt;-- The list of results when the function is&lt;/span&gt;
                                  &lt;span class=&quot;c1&quot;&gt;--   applied element-by-element to the given&lt;/span&gt;
                                  &lt;span class=&quot;c1&quot;&gt;--   lists.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Obviously, that&amp;#39;s an unnecessary amount of information, but it gives a far clearer picture of what the function really does.  Note that the description of each argument is able to be immediately next to the kind itself, which is nice for casual reading of the code, and the difference between the &lt;code&gt;-&amp;gt;&lt;/code&gt;&amp;#39;s in the function used to zip with and the &lt;code&gt;-&amp;gt;&lt;/code&gt;&amp;#39;s in the actual type signature.  In fact, the type signature serves as pretty much all the documentation the function needs.  Of course, the &lt;code&gt;|||&lt;/code&gt; documentation style also works well, but between commenting next to a stacked type signature and commenting above/below a function, I personally find the former much more legible.&lt;/p&gt;
</description>
                                <pubDate>Thu, 16 Oct 2014 00:00:00 -0500</pubDate>
                                <link>http://japesinator.github.io//2014/10/16/stacked_type_signatures/</link>
                                <guid isPermaLink="true">http://japesinator.github.io//2014/10/16/stacked_type_signatures/</guid>
                        </item>
                
                        <item>
                                <title>Types as Tests</title>
                                <description>&lt;h1&gt;Types as Tests&lt;/h1&gt;

&lt;p&gt;Recently, a friend of mine and I were going over the ages old tests vs. types debate.  Specifically, if a programmer wants to have some degree of certainty that their program will function as intended, does it work better to use unit testing or static typing?  However, the more I looked at the argument we were having, the less it made sense to me as a strict dichotomy.  Obviously, best practices for ensuring Python code works as intended are different from ensuring Haskell code works as intended, and you&amp;#39;ll catch some bugs with Python best practices that you won&amp;#39;t catch with Haskell best practices and vice versa, but in a sufficiently advanced language, assertions about the code are the same as function types and vice versa.&lt;/p&gt;

&lt;p&gt;For instance, consider the (rather trivial) example of a function that reverses lists.  In python:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[::&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In Idris&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-idris&quot; data-lang=&quot;idris&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;reverse&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; a &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; a
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; reverse &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; reverse&amp;#39; &lt;span class=&quot;ow&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt;   &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt;     &lt;span class=&quot;nf&quot;&gt;reverse&amp;#39;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; a &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; a &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; a
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt;     reverse&amp;#39; acc &lt;span class=&quot;ow&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; acc
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt;     reverse&amp;#39; acc &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt;xs&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; reverse&amp;#39; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt;acc&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; xs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Suppose we want to show that an example list reversed twice is itself.  In Python, we might try an assertion.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;unittest&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testVar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testVar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testVar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If we were doing something more complex, we could use &lt;a href=&quot;https://docs.python.org/2/library/unittest.html&quot;&gt;unittest&lt;/a&gt; or &lt;a href=&quot;https://nose.readthedocs.org/en/latest/&quot;&gt;nose&lt;/a&gt; or any number of other options, but for the sake of simplicity, we&amp;#39;ll stick with with &lt;code&gt;assert&lt;/code&gt; for now.&lt;/p&gt;

&lt;p&gt;Now we wish to make the same assertion about our idris function.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-idris&quot; data-lang=&quot;idris&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;testvar&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; testVar &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;reverseTwice&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; testvar &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; reverse &lt;span class=&quot;ow&quot;&gt;$&lt;/span&gt; reverse testvar
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; reverseTwice &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; refl&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Note that the assertion happens in the &lt;em&gt;type&lt;/em&gt; of &lt;code&gt;reverseTwice&lt;/code&gt;, not the definition like in the Python example, but the two serve the exact same purpose.  This is because an assertion is a proposition about a program, and a &lt;a href=&quot;https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence&quot;&gt;proposition is a type&lt;/a&gt;, so any assertion can be written as the type of a variable, given sufficient tools to do so.  The definition of the variable with that type then, is the proof of the proposition the assertion makes in the first place.  Notably, this allows us to use relatively advanced tactics to make much more powerful assertions than in languages without this functionality.  For instance, &lt;a href=&quot;http://sitr.us/2014/05/05/category-theory-proofs-in-idris.html&quot;&gt;Jesse Hallett&amp;#39;s category theory proofs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;One concrete example would be &lt;a href=&quot;https://github.com/defanor/idris-stuff/blob/master/Vect.idr&quot;&gt;this rewrite of reverse&lt;/a&gt; by defanor, that generalizes our earlier assertion to not just &lt;code&gt;testVar&lt;/code&gt;, but any Vect.  Obviously, this is more work than a simple assert statement, but an assert statement is also more work than not testing at all, and for code that &lt;em&gt;really needs to work&lt;/em&gt;, a proof that it always will work is often desirable.&lt;/p&gt;

&lt;p&gt;Obviously, there are types of testing that can&amp;#39;t be written as a type.  It&amp;#39;s unlikely that &lt;a href=&quot;http://www.seleniumhq.org/&quot;&gt;selenium&lt;/a&gt; can ever have a type-level equivalent, and something like &lt;a href=&quot;https://github.com/nick8325/quickcheck&quot;&gt;quickcheck&lt;/a&gt; that uses stochastic methods to give a fuzzier guarantee is a fundamentally different tactic, but the vast majority of unit testing is equivalent to simple types.  Not only that, but dependent types and totality checking allow us to check every possible value for a parameter against its expected output all at once using mathematical reasoning.  And while there is certainly a place for assertions, dependent types make them seem as primitive as the goto when it comes to ensuring program correctness.&lt;/p&gt;
</description>
                                <pubDate>Fri, 03 Oct 2014 00:00:00 -0500</pubDate>
                                <link>http://japesinator.github.io//2014/10/03/types_as_tests/</link>
                                <guid isPermaLink="true">http://japesinator.github.io//2014/10/03/types_as_tests/</guid>
                        </item>
                
                        <item>
                                <title>A Tale of Two Alls</title>
                                <description>&lt;h1&gt;A Tale of Two Alls&lt;/h1&gt;

&lt;p&gt;One of my favorite parts of programming in strongly typed languages is the ability to use the type signature of a function to figure out what it does.  For instance, &lt;code&gt;:t map&lt;/code&gt; returns either &lt;code&gt;map :: (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [b]&lt;/code&gt; in Haskell, or &lt;code&gt;Prelude.Functor.map : Functor f =&amp;gt; (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&lt;/code&gt; in idris, both of which make it relatively clear how map works (provided, in the case of idris, you&amp;#39;re at least moderately familiar with what a functor is.)  Both &lt;a href=&quot;http://projects.haskell.org/haskellmode-vim/&quot;&gt;haskellmode-vim&lt;/a&gt; and &lt;a href=&quot;https://github.com/idris-hackers/idris-vim&quot;&gt;idris-vim&lt;/a&gt; make it very easy to check types from inside the editor.&lt;/p&gt;

&lt;p&gt;Recently when I was working on a &lt;a href=&quot;http://writes.co.de/2014/09/29/proving_time_constancy_of_equality.html&quot;&gt;project of mine&lt;/a&gt; I came across two different &lt;code&gt;all&lt;/code&gt;s in idris.  One is quite intuitive and has type of &lt;code&gt;Prelude.Foldable.all : Foldable t =&amp;gt; (a -&amp;gt; Bool) -&amp;gt; t a -&amp;gt; Bool&lt;/code&gt;, which is quite similar to Haskell&amp;#39;s all, which has a type of &lt;code&gt;all :: (a -&amp;gt; Bool) -&amp;gt; [a] -&amp;gt; Bool&lt;/code&gt;, but another one has a type of &lt;code&gt;Data.Vect.Quantifiers.all : ((x : a) -&amp;gt; Dec (P x)) -&amp;gt; (xs : Vect n a) -&amp;gt; Dec (All P xs)&lt;/code&gt;.  Yet more confusing is the fact that in idris, &lt;code&gt;:t All&lt;/code&gt; (with a capital &amp;#39;A&amp;#39;) returns &lt;code&gt;Data.Vect.Quantifiers.All : (a -&amp;gt; Type) -&amp;gt; Vect n a -&amp;gt; Type&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;After finding this, I was fairly confused, as my intuitive understanding of &lt;code&gt;all&lt;/code&gt; was that it should take a list-like group of items and return a Boolean representing whether they all have some certain property.  This absolutely makes sense in with the &lt;code&gt;all&lt;/code&gt; defined in Prelude.Foldable and Haskell&amp;#39;s all, but the difference between &lt;code&gt;Type&lt;/code&gt;, &lt;code&gt;Dec (All P xs)&lt;/code&gt;, and a &lt;code&gt;Bool&lt;/code&gt; seemed hard to reconcile to me.&lt;/p&gt;

&lt;p&gt;Doing some more analysis, I decided to start by picking apart &lt;code&gt;Dec (All P xs)&lt;/code&gt;.  &lt;code&gt;:t Dec&lt;/code&gt; shows &lt;code&gt;Prelude.Basics.Dec : Type -&amp;gt; Type&lt;/code&gt; shows that apparently &lt;code&gt;Dec&lt;/code&gt; is a function from a Type to a Type, which isn&amp;#39;t necessarily helpful by itself, but &lt;code&gt;:doc Dec&lt;/code&gt; actually is, returning:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-lidr&quot; data-lang=&quot;lidr&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; Data type
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt; &lt;span class=&quot;cs&quot;&gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Dec&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Type&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt;     Decidability. A decidable property either holds or is a
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt;     contradiction.
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; Constructors:
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt; &lt;span class=&quot;cs&quot;&gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Yes&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;prf &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Dec&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt;         The case where the property holds
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt;         Arguments:
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;cs&quot;&gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;prf&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;-- the proof&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;cs&quot;&gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;No&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;contra &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Dec&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt;         The case where the property holding would be a contradiction
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt;         Arguments:
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt; &lt;span class=&quot;cs&quot;&gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;contra&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;-- a demonstration that A would be a contradiction&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now we&amp;#39;re getting somewhere.  &lt;code&gt;Dec&lt;/code&gt; takes as a parameter a type, but since this is idris, types and propositions are the same thing, and &lt;code&gt;Dec&lt;/code&gt; just states that either the proposition holds or doesn&amp;#39;t.  Since the proposition is either true (it can be shown to hold in this case) or false (it implies a contradiction if true), &lt;code&gt;Dec&lt;/code&gt; will return either &lt;code&gt;Yes&lt;/code&gt; or &lt;code&gt;No&lt;/code&gt;.  This is quite similar to a standard Bool, but arguably more useful in that it can speak about general cases and also state both whether the given statement is true or false, but also in some sense why.  For instance idris defines a class &lt;code&gt;DecEq&lt;/code&gt; as:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-idris&quot; data-lang=&quot;idris&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DecEq&lt;/span&gt; t &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;kr&quot;&gt;total&lt;/span&gt; decEq &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;x1 &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; t&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;x2 &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; t&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Dec&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;x1 &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; x2&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In some sense this serves the same purpose as &lt;code&gt;(==)&lt;/code&gt; (which has a type of &lt;code&gt;Prelude.Classes.(==) : Eq a =&amp;gt; a -&amp;gt; a -&amp;gt; Bool&lt;/code&gt; in idris), but because &lt;code&gt;(==)&lt;/code&gt; returns a &lt;code&gt;Bool&lt;/code&gt;, it can only tell us whether two things are equal, whereas &lt;code&gt;DecEq&lt;/code&gt; can tell us &lt;em&gt;why&lt;/em&gt; two things are equal.&lt;/p&gt;

&lt;p&gt;In fact, &lt;code&gt;DecEq&lt;/code&gt; is actually defined on Bools in Decidable.Equality as:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-idris&quot; data-lang=&quot;idris&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;total&lt;/span&gt; trueNotFalse &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;True&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;False&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; trueNotFalse &lt;span class=&quot;kt&quot;&gt;Refl&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;impossible&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DecEq&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt;   decEq &lt;span class=&quot;kt&quot;&gt;True&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;True&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Yes&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Refl&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt;   decEq &lt;span class=&quot;kt&quot;&gt;False&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;False&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Yes&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Refl&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;7&lt;/span&gt;   decEq &lt;span class=&quot;kt&quot;&gt;True&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;False&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;No&lt;/span&gt; trueNotFalse
&lt;span class=&quot;lineno&quot;&gt;8&lt;/span&gt;   decEq &lt;span class=&quot;kt&quot;&gt;False&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;True&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;No&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;negEqSym trueNotFalse&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Note the difference between this and the definition of &lt;code&gt;Eq&lt;/code&gt; for Bools, which is simply:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-idris&quot; data-lang=&quot;idris&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Eq&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;True&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;True&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;True&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;True&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;False&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;False&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;False&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;True&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;False&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;False&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;False&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The crucial difference between the two is that while &lt;code&gt;True == False = False&lt;/code&gt; says that True and False &lt;em&gt;are not&lt;/em&gt; equal, &lt;code&gt;decEq True False = No trueNotFalse&lt;/code&gt; says True and False &lt;em&gt;cannot&lt;/em&gt; be equal.  Back to the case of lists, if we look at the definitions of &lt;code&gt;All&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt;, we find:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-idris&quot; data-lang=&quot;idris&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;All&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; a &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Vect&lt;/span&gt; n a &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt;   &lt;span class=&quot;nf&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; a &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;All&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nil&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt;   &lt;span class=&quot;ow&quot;&gt;(::)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; a &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;{&lt;/span&gt;xs &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Vect&lt;/span&gt; n a&lt;span class=&quot;ow&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;P&lt;/span&gt; x &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;All&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;P&lt;/span&gt; xs &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;All&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; xs&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;notAllHere&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; a &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;{&lt;/span&gt;xs &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Vect&lt;/span&gt; n a&lt;span class=&quot;ow&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Not&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;P&lt;/span&gt; x&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;All&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; xs&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; notAllHere &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;impossible&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt; notAllHere np &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;p &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; np p
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;notAllThere&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; a &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;{&lt;/span&gt;xs &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Vect&lt;/span&gt; n a&lt;span class=&quot;ow&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Not&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;All&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;P&lt;/span&gt; xs&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;All&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; xs&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; notAllThere &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;impossible&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt; notAllThere np &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; ps&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; np ps
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;all&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; a &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;((&lt;/span&gt;x &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; a&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Dec&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;P&lt;/span&gt; x&lt;span class=&quot;ow&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;xs &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Vect&lt;/span&gt; n a&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Dec&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;All&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;P&lt;/span&gt; xs&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt; all &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Yes&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nil&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt; all d &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt;xs&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;d x&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt;   &lt;span class=&quot;ow&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;No&lt;/span&gt; prf &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;No&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;notAllHere prf&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt;   &lt;span class=&quot;ow&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Yes&lt;/span&gt; prf &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt;   &lt;span class=&quot;kr&quot;&gt;case&lt;/span&gt; all d xs &lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;19&lt;/span&gt;     &lt;span class=&quot;kt&quot;&gt;Yes&lt;/span&gt; prf&amp;#39; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Yes&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;prf &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; prf&amp;#39;&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;20&lt;/span&gt;     &lt;span class=&quot;kt&quot;&gt;No&lt;/span&gt; prf&amp;#39; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;No&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;notAllThere prf&amp;#39;&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This is now much clearer (at least to me.) &lt;code&gt;all&lt;/code&gt; takes a proposition, a way to verify that proposition, and a list of things, and returns why the proposition does or doesn&amp;#39;t hold for everything in the list.  It&amp;#39;s the difference between a multiple-choice and short-answer question, in that while they can state the same thing, the answer to one is much more helpful in reasoning about future questions than the other.  While a Bool is fine for simple questions, there&amp;#39;s a lot to be gained from using &lt;code&gt;Dec&lt;/code&gt; when it&amp;#39;s practical.&lt;/p&gt;

&lt;p&gt;One of the more interesting applications for this is &lt;a href=&quot;https://github.com/Ralith/quasigroup-completion&quot;&gt;this quasigroup completion solver&lt;/a&gt;, later adapted to a benchmark of idris itself.  A quasigroup is just a set for and an operation such that each element of the set appears exactly once in each row and column of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Cayley_table&quot;&gt;Cayley Table&lt;/a&gt; generated from the elements in the set and the operation.  This property also means that the quasigroup completion problem is often referred to as the Latin Square problem, since said Cayley table is also a &lt;a href=&quot;https://en.wikipedia.org/wiki/Latin_square&quot;&gt;Latin Square&lt;/a&gt; by definition.  It is a common combinatorial problem to take a given partially filled Latin Square and complete it in a way consistent with the definition.  This process is actually quite similar to sudoku, where a grid of spaces that are either empty or containing a value are given, and the goal is to fill in the empty squares so that the same number does not appear twice in any row or column.  Of course, quasigroup completion is a more general and abstract problem, but the fundamental process is the same.&lt;/p&gt;

&lt;p&gt;The solver shown uses the Data.Vect.Quantifier version of &lt;code&gt;all&lt;/code&gt; to reason about things like whether given rows and columns are &amp;quot;safe&amp;quot; to place an element in, perhaps most notably in the definition of legalVal, which is used to evaluate whether a given cell assignment is &amp;quot;legal&amp;quot; with regard to the definition of quasigroup.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-idris&quot; data-lang=&quot;idris&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LegalVal&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Board&lt;/span&gt; n &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Fin&lt;/span&gt; n, &lt;span class=&quot;kt&quot;&gt;Fin&lt;/span&gt; n&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fin&lt;/span&gt; n &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Type&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;LegalVal&lt;/span&gt; b &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;x, y&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; val &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;getCell b &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;x, y&lt;span class=&quot;ow&quot;&gt;))&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;All&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;LegalNeighbors&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; val&lt;span class=&quot;ow&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;getCol x b&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;All&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;LegalNeighbors&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; val&lt;span class=&quot;ow&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;getRow y b&lt;span class=&quot;ow&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;legalVal&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;b &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Board&lt;/span&gt; n&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;coord &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Fin&lt;/span&gt; n, &lt;span class=&quot;kt&quot;&gt;Fin&lt;/span&gt; n&lt;span class=&quot;ow&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;val &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fin&lt;/span&gt; n&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Dec&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;LegalVal&lt;/span&gt; b coord val&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; legalVal b &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;x, y&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; v &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;case&lt;/span&gt; rowSafe b y v &lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;No&lt;/span&gt; prf &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;No&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(\(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;, &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;, rf&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; prf rf&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;Yes&lt;/span&gt; prf &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt;   &lt;span class=&quot;kr&quot;&gt;case&lt;/span&gt; colSafe b x v &lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt;     &lt;span class=&quot;kt&quot;&gt;No&lt;/span&gt; prf&amp;#39; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;No&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(\(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;, cf, &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; prf&amp;#39; cf&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt;     &lt;span class=&quot;kt&quot;&gt;Yes&lt;/span&gt; prf&amp;#39; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt;     &lt;span class=&quot;kr&quot;&gt;case&lt;/span&gt; empty &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;getCell b &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;x, y&lt;span class=&quot;ow&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt;       &lt;span class=&quot;kt&quot;&gt;No&lt;/span&gt; prf&amp;#39;&amp;#39; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;No&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(\(&lt;/span&gt;ef, &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;, &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; prf&amp;#39;&amp;#39; ef&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt;       &lt;span class=&quot;kt&quot;&gt;Yes&lt;/span&gt; prf&amp;#39;&amp;#39; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Yes&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;prf&amp;#39;&amp;#39;, prf&amp;#39;, prf&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the definition of &lt;code&gt;legalVal&lt;/code&gt;, &lt;code&gt;prf&lt;/code&gt;, &lt;code&gt;prf&amp;#39;&lt;/code&gt;, and &lt;code&gt;prf&amp;#39;&amp;#39;&lt;/code&gt; all refer to proofs of the &amp;quot;safety&amp;quot; of the given value at the given coordinates with respect to its row, column, and occupancy status.  This allows &lt;code&gt;LegalVal&lt;/code&gt; to be a type that only represents legal values, and thus guarantee that functions using that type can only ever give legal values, because otherwise the program would type check.  Not that this is totally impossible in a language like Haskell with no dependant types, as you cannot have a function like &lt;code&gt;LegalVal&lt;/code&gt; to a type, and hence the type cannot &lt;em&gt;depend&lt;/em&gt; on parameters that aren&amp;#39;t other types, and hence can&amp;#39;t carry guarantees about them like in a language like idris.&lt;/p&gt;

&lt;p&gt;This makes our initial question of the behavior of the two &lt;code&gt;all&lt;/code&gt;s much simpler.  One returns either True or False, and the other returns either &lt;code&gt;Yes&lt;/code&gt; or &lt;code&gt;No&lt;/code&gt;, but the second provides a reason for the returned value that can be used to reason about the behavior of the program in general and guarantee certain behaviors.&lt;/p&gt;
</description>
                                <pubDate>Tue, 30 Sep 2014 00:00:00 -0500</pubDate>
                                <link>http://japesinator.github.io//2014/09/30/a_tale_of_two_alls/</link>
                                <guid isPermaLink="true">http://japesinator.github.io//2014/09/30/a_tale_of_two_alls/</guid>
                        </item>
                
                        <item>
                                <title>Proving Time-Constancy of Equality</title>
                                <description>&lt;h1&gt;Proving Time-Constancy of Equality&lt;/h1&gt;

&lt;p&gt;Lately I&amp;#39;ve been working with &lt;a href=&quot;http://www.idris-lang.org/&quot;&gt;idris&lt;/a&gt; a bunch. Idris is a purely functional, dependently-typed, programming language, which, to quote one of my friends, makes it &amp;quot;Haskell for Haskell people.&amp;quot; There are a lot of things that it does well, but one of the most interesting ones is that dependent types and the Curry-Howard isomorphism allow the writing of propositions as types and the proofs thereof to be written as the values for the variables of those types.  For example:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-idris&quot; data-lang=&quot;idris&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;total&lt;/span&gt; eqSucc &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;left &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nat&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;right &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nat&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;p &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; left &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; right&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt; left &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt; right
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; eqSucc left &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; refl &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; refl&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The above is a function taken from idris&amp;#39; &lt;a href=&quot;https://github.com/idris-lang/Idris-dev/tree/master/libs/prelude/Prelude&quot;&gt;prelude&lt;/a&gt;, which is the standard library that contains most of the basic functions and proofs.  It states that if you have two natural numbers and a proof that they are equal, the successor to the first is equal to the successor to the second, and that the proof is true from the reflexive property.&lt;/p&gt;

&lt;p&gt;This is also notable in that the same module both defines natural numbers and proves many of their properties, erasing the line between proof and program. Similarly, the module that defines the vector type also contains proofs about vectors, the module that defines lists contains proofs about lists, and so on. This is quite useful in that when you import these modules, you not only get the data types and the basic functions on them, but also the tools for reasoning about their generalized behavior.&lt;/p&gt;

&lt;p&gt;In my humble opinion, some of the most interesting proofs in computer science are those about algorithm runtime. The big O runtime analyses in The Art of Computer Programming some of the most elegant and beautiful proofs I have ever seen, and as soon as I saw idris&amp;#39; proof system, I was immediately curious about how to implement these.  This also has several practical applications, as there have &lt;a href=&quot;https://www.schneier.com/paper-side-channel.html&quot;&gt;been&lt;/a&gt; &lt;a href=&quot;http://dl.acm.org/citation.cfm?id=706156&quot;&gt;some&lt;/a&gt; &lt;a href=&quot;http://cr.yp.to/papers.html#cachetiming&quot;&gt;problems&lt;/a&gt; with people not verifying that certain algorithms in cryptography are time-constant.&lt;/p&gt;

&lt;p&gt;Perhaps the clearest example of how this might be a problem is equality.  Equality between two bitstrings is often implemented by comparing bits of the same index one by one until either an inequality is found (and then returning False) or there aren&amp;#39;t any bits left (and then returning True).  This is usually pretty good, but it&amp;#39;s notable that comparing &lt;code&gt;00000001&lt;/code&gt; and &lt;code&gt;00000000&lt;/code&gt; takes a long time, since it doesn&amp;#39;t halt until all eight bits have been compared, but when &lt;code&gt;00000001&lt;/code&gt; and &lt;code&gt;10000000&lt;/code&gt; are compared, the comparison algorithm returns false as soon as the first bit is compared (assuming the algorithm scans from left to right.) In other words, the time the algorithm takes is a function of the &amp;quot;close-ness&amp;quot; of the two things being compared.&lt;/p&gt;

&lt;p&gt;This is usually totally fine, but occasionally crypto algorithms need to compare things to some really sensitive data.  To use a contrived example, imagine a system that has you enter a password, compares it to a known correct password, and returns whether the two are equal.  Ideally, you would have to simply try passwords until you found one that&amp;#39;s right, which if our password is only eight bits, takes about 89 guesses to have better-than-even odds of guessing the password.  However, if the program uses the equality algorithm described above, we can just try two bitstrings, one of which starts with 0 and one of which starts with 1, and whichever one takes longer to evaluate has the correct first bit.  We can then repeat this process with the correct first bit and bitstrings with 0 for the second bit and 1 for the second bit. By repeating this eight times, we can always get the key in with a maximum of 16 guesses, two for each bit.  Also note that as the size of our key increases, the number of guesses to get it by chance increases exponentially, but the number of guesses to get it by timing attack only increases linearly.&lt;/p&gt;

&lt;p&gt;Slightly more elaborate versions of this attack have been used to successfully exploit AES, SSL, RSA, and most other common crytosystems on at least some level.  This is probably a bad thing.  I thus decided to write a program as proof-of-concept that compares two bytes but also proves that that comparison will always take the same time for any two pairs of bytes.  This algorithm can be found &lt;a href=&quot;https://github.com/japesinator/tarts&quot;&gt;on my github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The equality comparison itself is quite simple.  First, bits are defined as either One or Zero, and bytes are defined as a vector of eight bits.  Then, to compare the equality of two bytes, we zip them together with not xor and then fold across the resulting list with And.  Not xor returns one only if the two bits it operates on are the same, so zipping two lists with it creates a new list with one in the indices where the two lists have matching values and zero where the two lists have differing values.  And can only return one if both of its input values are one, so folding it across a list will return one only if all values in the list are one, and zero otherwise.  Thus, zipping with not xor and folding with and will return one if and only if the two lists are the same, which is the definition of equality.  At some point it&amp;#39;s likely worth proving this formally, but I have yet to do that.&lt;/p&gt;

&lt;p&gt;To prove time-constancy, I decided to prove that the number of primitive operations performed on bits is the same no matter what the bits are, and thus the time will be constant.  This isn&amp;#39;t perfect due to the pattern-matching implementation of boolean logic I provided, but it&amp;#39;s close enough for proof of concept.  To do this I wrote what&amp;#39;s essentially a monad (I have yet to make it an instance of the monad typeclass, but that&amp;#39;s on my todo list) that tracks the number of operations performed to yield a given bit.  The core code for this is below&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-idris&quot; data-lang=&quot;idris&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addCount&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;a &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; a&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;a, &lt;span class=&quot;kt&quot;&gt;Nat&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;a, &lt;span class=&quot;kt&quot;&gt;Nat&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;a, &lt;span class=&quot;kt&quot;&gt;Nat&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; addCount f &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;a, n&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;b, m&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;(&lt;/span&gt;f a b, n &lt;span class=&quot;ow&quot;&gt;+&lt;/span&gt; m &lt;span class=&quot;ow&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This essentially turns a regular function from two elements of the same type to another and turns it into a function that does the same thing but counts operations. The natural number that is the second element of each tuple represents the number of operations performed to yield that value.  It takes a function and two tuples of a value and an operation count and returns a tuple of the function applied to the first elements of each tuple and one plus the counts added together, the one coming from the operation that just took place.&lt;/p&gt;

&lt;p&gt;To write a version of equality that also provides an operation count, we can write the same equality function as before, but using (addCount bibNXOR) instead of bitNXOR and (addcount bitAnd) instead of bitAnd and (initializeCount a) and (initializeCount b) for the two bytes being compared, where initializeCount just maps &lt;code&gt;(\x =&amp;gt; (x,0))&lt;/code&gt; on a vector, saying that (relative to our function) it took no operations to produce the initial values, as they were just given to us.&lt;/p&gt;

&lt;p&gt;This function will return a tuple of a bit representing whether the two bytes are equal and a natural number representing the number of operations that took place to compare them.  It&amp;#39;s arguable that sing a single natural number is an oversimplification, as bitNXOR and bitAnd could conceivably take different times, and it should instead return a bit and a table of functions used and the number of times they were used, and I may change the behavior of addCount at some future point to provide this functionality, but at the moment it doesn&amp;#39;t seem necessary to me.&lt;/p&gt;

&lt;p&gt;Once we have this function, we can write a number of lemmas to eventually give us a proof with type of &lt;code&gt;(a,b,c,d:Byte) -&amp;gt; snd (countingByteEq a b) = snd (countingByteEq c d)&lt;/code&gt;, or for any two pairs of bytes, the time to compare them is equal.  I&amp;#39;m not going to walk through the proof of that in this blog post, as at the moment it&amp;#39;s hideous, but the code does include a working, total proof of that proposition.&lt;/p&gt;

&lt;p&gt;Clearly, there&amp;#39;s still work to be done even on the definition of equality, but the fundamental principles are sound, and hopefully similar tactics can be used on a larger scale to prove time-constancy for things like RSA and AES where that&amp;#39;s actually really important.&lt;/p&gt;
</description>
                                <pubDate>Mon, 29 Sep 2014 00:00:00 -0500</pubDate>
                                <link>http://japesinator.github.io//2014/09/29/proving_time_constancy_of_equality/</link>
                                <guid isPermaLink="true">http://japesinator.github.io//2014/09/29/proving_time_constancy_of_equality/</guid>
                        </item>
                
                        <item>
                                <title>A Personal Update</title>
                                <description>&lt;h1&gt;A Personal Update&lt;/h1&gt;

&lt;p&gt;I don&amp;#39;t mean to become the person from &lt;a href=&quot;https://xkcd.com/621/&quot;&gt;the XKCD&lt;/a&gt;, but I will apologize for not posting much lately.  I&amp;#39;ve been really busy with a few projects which I hope to post about soon, but in short:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;On the Boy Scouting front, I&amp;#39;m now director of STEM at &lt;a href=&quot;http://isrsummercamp.org/&quot;&gt;Ingersoll Scout Reservation&lt;/a&gt;. Since this is a new area this year, I&amp;#39;m designing a bunch of material to teach important things but still be as accessible as possible to people without much high school math or even electricity.  I&amp;#39;m now Vice Chief of Administration for &lt;a href=&quot;http://wq23.org/&quot;&gt;Wenasa Quenhotan Lodge&lt;/a&gt;, so I&amp;#39;ll be managing some financial things and setting up some new technology&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;On the academic side of things, I&amp;#39;ve been working on a project to produce a paper about UAVs.  I&amp;#39;ll probably be working on implementing some crypto that can resist both smart attackers with fast computers and the kind of packet loss you get when your only communication method is wireless to a drone 100 meters in the air.  Also, I&amp;#39;ve been doing a bunch of stuff with &lt;a href=&quot;isusec.com&quot;&gt;ISUSec&lt;/a&gt;, where I&amp;#39;ve been presenting about crypto and reverse engineering.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;On the personal side of things, I&amp;#39;ve been taking a couple courses at &lt;a href=&quot;http://coursera.org&quot;&gt;Coursera&lt;/a&gt; in Cryptography and Machine Learning, and have been writing a tic-tac-toe AI and a (somewhat) R5RS compliant scheme in Haskell.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So essentially, I&amp;#39;ve been really busy, but for good reasons, and I&amp;#39;ll post more soon.&lt;/p&gt;
</description>
                                <pubDate>Sat, 22 Feb 2014 00:00:00 -0600</pubDate>
                                <link>http://japesinator.github.io//2014/02/22/update/</link>
                                <guid isPermaLink="true">http://japesinator.github.io//2014/02/22/update/</guid>
                        </item>
                
                        <item>
                                <title>Things I Learned Writing Trapifier.py</title>
                                <description>&lt;h1&gt;Things I Learned Writing Trapifier.py&lt;/h1&gt;

&lt;p&gt;Recently on reddit.com/r/hiphopheads, someone requested that a cover of a John Mayer song, except with trap adlibs (i.e. gunshots, airhorns, &amp;quot;DAMN SON WHERE&amp;#39;D YOU FIND THIS!?&amp;quot;).  Since this was reddit, this request was obviously &lt;a href=&quot;http://www.reddit.com/r/hiphopheads/comments/1vxdag/guys_i_need_a_favor/cewq9ao&quot;&gt;quickly fulfilled&lt;/a&gt; and the result was as hilarious and awesome as one would expect.  In the thread, people also posted a &lt;a href=&quot;https://www.youtube.com/watch?v=Hu8yGh5aEwA&quot;&gt;bunch&lt;/a&gt; &lt;a href=&quot;https://soundcloud.com/hennessyyoungman/cvsbangers&quot;&gt;of&lt;/a&gt; &lt;a href=&quot;https://www.youtube.com/watch?v=LNT-b-yfM58&amp;amp;feature=youtu.be&quot;&gt;links&lt;/a&gt; to other trap remixes of popular songs were posted.&lt;/p&gt;

&lt;p&gt;I saw these and naturally thought it would be pretty fun to make my own trap remix, but I A: didn&amp;#39;t really want to play around in audacity and try to get all the samples reasonable, and B: couldn&amp;#39;t decide on just one song.  Naturally, I thought to make a script that would &amp;quot;trapify&amp;quot; songs for me, which would solve both my problems at the same time.  I sat down in front of vim and got to work.&lt;/p&gt;

&lt;p&gt;The actual code for trapifier.py is fairly simple, and it&amp;#39;s all up on my &lt;a href=&quot;https://github.com/japesinator/trapifier.py&quot;&gt;github&lt;/a&gt;.  While a code analysis could be done, in my opinion, a far more interesting analysis is that of the design and distribution of the code.  Thus, below is my list of things learned writing trapifier.py.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  Python has libraries for &lt;em&gt;everything&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I was at first a little worried about actually handling the audio files in python, since my knowledge of audio codecs and how to  manipulate them is fuzzy at best, but a quick google search for &amp;quot;mix audio in python&amp;quot; turned up &lt;a href=&quot;http://pydub.com/&quot;&gt;pydub&lt;/a&gt;, which ended up solving pretty much all my audio problems at once.  Later, when I was trying to make it work well from the command line and failing miserably to get optional arguments to work like I wanted, another google search turned up &lt;a href=&quot;http://docs.python.org/dev/library/argparse.html&quot;&gt;argparse&lt;/a&gt;, which might be the single most useful python library I&amp;#39;ve seen since os.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  Computer-timed isn&amp;#39;t always better than random&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When I first started the project, I thought that I would make the overlaying function context-dependant, so that for instance when the song crescendoed, the algorithm would place &amp;quot;bigger&amp;quot; samples.  But, as it turns out, this kind of analysis is hard, and the changes in songs significant enough to be picked up by my (admittedly clumsy) algorithms were so infrequent as to place samples far too infrequently.  Instead, I chose to place a sample every 1.5-6 seconds and hope that it would sync well.  As it turns out, this actually works about as well as manual placement, albeit much faster.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  r/hiphopheads has a surprising number of programmers.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For music-focused subreddit, the number of intelligent programmers on r/hiphopheads is surprisingly high.  While there were some comments along the lines of &amp;quot;You go to MIT?!?!&amp;quot; (because I MIT licensed the code) and &amp;quot;Super dope script bruh. Algorithmically this is some e=mc2 shit,&amp;quot; there were also a surprising number of helpful comments about the actual code and what to do with it.  People talked about refactoring code and using os.path.join for more cross-compatibility and generally gave helpful advice about the design of the program, something I did not see coming from where it did.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  Windows is hard.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For reference, I don&amp;#39;t actually own a Windows machine I can test on, so maybe I&amp;#39;m exaggerating here, but it seems to me that it would take more time to get the script to work on Windows (without python already installed) than it would to write it in the first place.  At some point I should probably learn Windows, as pretty much everything I do with computers I do worse on Windows, but that point has yet to arrive.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  Programming is really fun&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I suppose I didn&amp;#39;t really &lt;em&gt;learn&lt;/em&gt; this, since I had known it before, but the actual writing of the code for this project was one of the most enjoyable things I had done in a while.&lt;/p&gt;
</description>
                                <pubDate>Mon, 27 Jan 2014 00:00:00 -0600</pubDate>
                                <link>http://japesinator.github.io//2014/01/27/things_learned_trapifying/</link>
                                <guid isPermaLink="true">http://japesinator.github.io//2014/01/27/things_learned_trapifying/</guid>
                        </item>
                
                        <item>
                                <title>On Set</title>
                                <description>&lt;h1&gt;On Set&lt;/h1&gt;

&lt;p&gt;For those not familiar, &lt;a href=&quot;https://en.wikipedia.org/wiki/Set_%28game%29&quot;&gt;Set&lt;/a&gt; is a relatively simple board game played in real time by assembling &amp;quot;sets&amp;quot; of cards.  Each card in the game has four attributes (shape, color, number, and filling) which can each be any of three different values ((oval, squiggle, or diamond), (red, blue, or green), (one, two, or three), and (empty, shaded, or full), respectively).  A &amp;quot;set&amp;quot; is only valid if for each attribute, each of the three cards in the set either has the same value or no two cards have the same value.  For instance, one solid red diamond, two shaded blue ovals, and three empty green squiggles would make a set because no two cards share an attribute.  One solid red oval, two solid red ovals, and three solid red ovals are also a set because they all have the same filling, color, and shape, but they all have a different number.  In general, a set has no &lt;em&gt;pairs&lt;/em&gt; of attributes, just triplets or uniques.&lt;/p&gt;

&lt;p&gt;For this reason, cards lend themselves to representation as a four-element array of ternary values representing their attributes.  For instance, a 0 in the first element of the array could mean oval, a 1 diamond, and a 2 squiggle.  The only question is whether to use standard ternary or &lt;a href=&quot;https://en.wikipedia.org/wiki/Balanced_ternary&quot;&gt;balanced ternary&lt;/a&gt;.  While balanced ternary has a number of computational advantages, for our purposes, standard 0-1-2 ternary actually allows us some computational shortcuts.  Firstly, a function to find out whether a given triplet of cards is a set, which would normally be horrendously ugly and check for any possible pair of matching values with no triplet can instead be written as below.  Note that the sum function, which cleans up the code a bit, would not always work with balanced ternary.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;is_set&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;is_set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;card0&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;card1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;card2&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zipWith&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;card0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zipWith&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;card1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;card2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;True&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;-- First we sum the numbers in each card mod 3, and then we sum the numbers in that array&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;-- This can only result in zero if the array is [0,0,0,0]&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;7&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherwise&lt;/span&gt;                                                              &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The above code hardly does anything to help the stereotype of Haskell as unreadable, but with a little analysis it is both clear and elegant.  Given three lists, it creates a new list where each element is the sum of the elements in the same place in the original list modulo three, then checks if that list is entirely zeroes by summing it. So given [a,b,c,d], [e,f,g,h], and [i,j,k,l], if (a + e + i) % 3 + (b + f + j) % 3 + (c + g + k) % 3 + (d + h + l) % 3 == 0, it returns true.  Otherwise, it returns false.  This works because 3n % 3 == 0 while n is any number and (0 + 1 + 2) % 3 == 0, but (2n + m) % 3 != 0 while 0 &amp;lt;= n, m &amp;lt;= 2.&lt;/p&gt;

&lt;p&gt;Another interesting problem is the number of total sets.  This can be approached from a number of different ways.  Perhaps the most intuitive is by looking at the number of possible sets in a game with only one attribute, a game with only two attributes, and so on onto a game of four attributes.  While perhaps the most mathematically &amp;quot;pure&amp;quot; method, this is also challenging and an unnecessary amount of work.  Instead, we can rely on the modulo arithmetic discussed above.  Since a set is only valid when the sum mod 3 of its attributes represented numerically is 0, given two attributes we can deduce the value of the third necessary to complete the set.  There will also be only one value between zero and two that works, so a pair of attributes implies a unique third to have a valid set.  This means that any pair of cards implies a unique third card that completes a set with them.&lt;/p&gt;

&lt;p&gt;The naive interpretation of this is that the number of possible sets is equal to the number of possible pairs, but that forgets that a group of three cards contains three different pairs ((0,1), (1,2), (0,2)), and that each pair can be revealed one of two ways.  Thus, the number of possible sets is equal to the number of possible pairs divided by three times two.  Since there are 81 cards, the total number of possible sets is (81 * 80) / (3 * 2), which is the same as (27 * 40), which is 1080.  This also means that drawing two cards off of a fresh deck, there is only one card in the deck that forms a set with them, so the odds that three random cards form a set is one over the number of cards in the deck minus two, or 1/79.  Wikipedia confirms these numbers if not the reasoning behind them.  This even solves our earlier problem about the number of possible sets in a game with n attributes, because the only thing in our math that changes with a different number of attributes is the deck size, which is now equal to 3^n.  Thus, the number of possible sets in a game with n attributes, assuming there is exactly one card for every combination of attributes, is (3^n * (3^n -1)) / (6), which simplifies to (3^(2n -1) - 3^(n-1)) / 2.&lt;/p&gt;

&lt;p&gt;Also interesting is the actual playing of set.  If we want to write a program to analyze an array of cards and select sets from it, we have an huge selection of options.  Perhaps the most tempting is just to create a list comprehension that looks at every triplet of cards and checks if it is a valid set.  This would be easy to implement, but would have something like O(n^3) runtime because it runs its large, complex operation for every possible triple of cards, which, if there are n cards, means that it runs (n)(n-1)(n-2) times.  Reducing the runtime significantly below that is hard, because we fundamentally working with all possible triples (Assuming we don&amp;#39;t just use some massive hash table of all possible groups of cards), and this lends itself heavily to what is essentially a triple nested loop, but we can optimize a lot by instead looking at every pair of cards, computing the third card necessary, and searching for it.  Code to do that is shown below.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_third_card&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_third_card&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;card0&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;card1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zipWith&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zipWith&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;card0&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;card1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This is an improvement because the computationally expensive step is only performed a bit less than n^2 times, while the computationally cheap comparison takes up the rest of the cycles.  Working this into actual code, we can see an improvement of almost n - 2 times, where n is the number of cards we are analyzing.  Below is a four-line program to get a set from a given group of cards.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cards&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bunch&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;four&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arrays&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_third_card&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- This is just a type definition.  It&amp;#39;s a bit like declaring variables with types is a C like language.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_third_card&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;card0&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;card1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zipWith&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zipWith&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;card0&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;card1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- The third card will sum with the first two to [0, 0, 0, 0] mod 3, see code above for why&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt;  &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cards&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cards&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cards&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_third_card&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- The set found is just the first from the list of valid sets.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;One of the reasons I love Haskell is that it&amp;#39;s possible to write an AI for a complex board game in four relatively simple lines of code, and that the way the algorithm plays set is more or less the same way I do.&lt;/p&gt;
</description>
                                <pubDate>Thu, 23 Jan 2014 00:00:00 -0600</pubDate>
                                <link>http://japesinator.github.io//2014/01/23/on_set/</link>
                                <guid isPermaLink="true">http://japesinator.github.io//2014/01/23/on_set/</guid>
                        </item>
                
                        <item>
                                <title>Bitwise Galois Arithmetic</title>
                                <description>&lt;h1&gt;Bitwise Galois Arithmetic&lt;/h1&gt;

&lt;p&gt;Recently, I began working on implementing AES in python.  My code is largely based off of &lt;a href=&quot;https://code.google.com/p/slowaes/&quot;&gt;SlowAES&lt;/a&gt;, but using much more in-depth comments, more descriptive variable names, and snake case.  I understood most of the code, but there was a function for performing &amp;quot;Galois Multiplication&amp;quot; for column mixing that I was unable to deduce the function of entirely.  It is reproduced below, sans comments.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;galois_multiplication&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;hi_bit_set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x80&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xFF&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hi_bit_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1b&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;A quick wikipedia search for &amp;quot;Galois Multiplication&amp;quot; returned a &lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_field_arithmetic&quot;&gt;page&lt;/a&gt; that seemed to be about the same thing, but not in any way I could relate back to the actual code.  There was no simple English version I could find, so I looked into the &lt;a href=&quot;http://www.samiam.org/galois.html&quot;&gt;link&lt;/a&gt; at the bottom of the page, which seemed to be about the same thing I was looking for.&lt;/p&gt;

&lt;p&gt;Here I found some C code that the code I was looking at was obviously based off of, and a relatively simple explanation of what it did.  Based on that and using my rudimentary knowledge of bitwise operators in python, I was able to line-by-line annotate the code with the purpose of each line.&lt;/p&gt;

&lt;p&gt;To understand line 4, &amp;quot;if b &amp;amp; 1&amp;quot;, we must first understand three things:&lt;/p&gt;

&lt;p&gt;1:  When given a number as a conditional, python evaluates true if that number does not equal 0 and false if it does.&lt;/p&gt;

&lt;p&gt;2:  &amp;amp; represents bitwise and in python&lt;/p&gt;

&lt;p&gt;3:  In python, binary numbers are treated like integers, so 0b1 == 0b01 == 0b001, and therefore n &amp;amp; 0b1 == n &amp;amp; 0b001.&lt;/p&gt;

&lt;p&gt;Hence, the if statement first essentially performs a bitwise and on the binary representation of b and a binary number of equal length consisting of zeroes in all but the least significant place and a one in that place and then checks if the result is not equal to zero.  All this does is executes the code inside the &amp;#39;if&amp;#39; if the least significant bit of b is one.  Simplifying further, we can see that the conditional just checks if b is odd, albeit in a faster and less easily comprehensible way.&lt;/p&gt;

&lt;p&gt;The line inside the if statement is much easier to understand.  In python ^= is similar to += in that a ^= b is the same as a = a ^ b.  ^ is the bitwise xor function, so all that this line does is xors p with a.&lt;/p&gt;

&lt;p&gt;The next line, &amp;quot;hi&lt;em&gt;bit&lt;/em&gt;set = a &amp;amp; 0x80&amp;quot; is again, an application of pythons bitwise and to perform an operation quickly, but in a way that is hard to deduce from the code.  Converting 0x80 to decimal and then to binary we find that 0x80 == 128 == 0b10000000.  Bitwise and of any number with zero is zero, so our output will return 0b10000000 if a has a 1 in the 128&amp;#39;s place and 0 otherwise.  This is important at line 11, which checks whether this bit was set earlier.&lt;/p&gt;

&lt;p&gt;Now that we have checked whether a&amp;#39;s highest bit was set, we can modify it with a &amp;lt;&amp;lt;=1, which simply shifts each bit to the right and adds a zero to the end, or in decimal, multiplies a by 2.&lt;/p&gt;

&lt;p&gt;Line 8 took me a while to understand the purpose of. 0xFF == 0b11111111, and if n is any bit, n &amp;amp; 1 == 1, so at first is looked to me like this line did not even modify a.  However, this is the same trick as used in line 4.  Applying a bitwise and to a number and a string of ones n bits long truncates that number to its least significant n bits.  Line 8 therefore makes sure that a is only 8 bits long after a left bitshift that could make it longer than that.&lt;/p&gt;

&lt;p&gt;In the next line, we use the high-bit-set test we devised before to see if a was &amp;gt;= 128 prior to our bitshift and truncation.  If it was, we xor a with 0x1b. 0x1b == 27 == 0b00011011, which has no easily apparent special properties, and only makes sense in the context of the actual math the function is based upon.&lt;/p&gt;

&lt;p&gt;After the second conditional has been evaluated, we shift b to the right one bit, essentially dropping the least significant bit and then dividing it by two.  We repeat this 8 times, and we have our function.&lt;/p&gt;

&lt;p&gt;Based on my analysis of the function, I was able to rewrite it and comment it to what I found a much easier to understand, if still somewhat cryptic functions, seen below.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;galois_multiplication&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second_number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;product&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;# Repeat the indented block below eight times&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second_number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;# If b is odd,&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;product&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;product&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt;       &lt;span class=&quot;c&quot;&gt;# xor the product with first_number&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first_number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;high_bit_set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt;       &lt;span class=&quot;c&quot;&gt;# Remember if a was greater than or equal to 128 here&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;first_number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;# double the first number&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first_number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;# This conditional essentially sets the first number equal to itself modulo 256&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;first_number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first_number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;high&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;# If the first number was &amp;gt;= 128, xor it with 27&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;19&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;first_number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first_number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;0b00011011&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;20&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;# The three lines below are the same as b &amp;gt;&amp;gt;=1&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;21&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second_number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;22&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;second_number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second_number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;23&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;second_number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second_number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;24&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;product&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;While this is certainly easier to understand from an arithmetic point of view, the overall purpose of the code is still a mystery.  To understand it, we must first understand why it is used.&lt;/p&gt;

&lt;p&gt;Galois arithmetic is a family of functions analogous to standard arithmetic that only takes and returns numbers from a finite field of values.  AES uses Galois arithmetic heavily for reasons that are too complex to explain well in a post of this scale, but which can be poorly summarized by pointing out that they can be counted on to only return certain numbers and aren&amp;#39;t too easy to reverse.&lt;/p&gt;

&lt;p&gt;We might expect that since Galois arithmetic is analogous to our own arithmetic, Galois multiplication is simply repeated Galois addition.  However, since Galois addition of two numbers is actually equivalent to simply bitwise xoring them, and (a ^ b) ^ b == a, Galois-adding two numbers together any number of times can only result in two values.  &lt;a href=&quot;http://www.pclviewer.com/rs2/galois.html&quot;&gt;This website&lt;/a&gt;, offers a fairly good explanation of exactly what Galois field arithmetic is and how to do it, and it provides that multiplication is the &amp;quot;Antilog of the modulus 256 sum of their logs.&amp;quot;  This, while it certainly does not make our function clear, offers at least a better explanation than we have seen so far.&lt;/p&gt;

&lt;p&gt;Looking at our definition, we already know how to perform modulo 256 addition, but logs and antilogs are both more complex in a Galois field than they are in basic arithmetic.  In standard arithmetic, if log base a of b equals c, c a to the c power equals b.  In other words, logs are the inverse of exponentiation.  If we try to directly translate this to a Galois field however, we encounter a problem in that exponentiation is repeated multiplication, and multiplication is the function we&amp;#39;re trying to create in the first place.  Looking for less circular definitions, we find on the aforementioned Wikipedia page, that multiplication in a finite field is just multiplication modulo the polynomial that defines the field.  This makes much more sense if we are able to look at numbers written in a base n system as polynomials.  For instance, if I write the number 1365, I have written the equivalent of the polynomial 1x^3 + 3x^2 + 6x^2 + 5x^0 where x is the base of the number system I am writing in.&lt;/p&gt;

&lt;p&gt;In AES&amp;#39;s finite field, numbers are expressed as binary, so that base is two.  The irreducible polynomial that defines the field is actually 283, or 0b100011011.  Notably, 0b100011011 % 256 (or 0b10000000) = 0b11011 (or 27) which at least partially explains where the mysterious constant in line 10 comes from.  Thus, when we want to multiply in a Galois field, we can simply multiply our two numbers like usual and then take the result modulo 283.  This certainly makes it clearer exactly what we are doing, and even allows us to rewrite our code as:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;galois_multiplication&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;283&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This is definitely an improvement from our initial algorithm in terms of legibility, but it is still hard to understand how they do the same thing.  Notably, in our original algorithm, p is only modified by xoring it with a.  Since in a Galois field, multiplication is equivalent to xor, we can begin to see how multiplication is still repeated addition in a Galois field, albeit slightly more complex.  We can also notice how the for loop runs eight times, once for each bit in the numbers.  Knowing this, we can look at the code as a set of simpler instructions:&lt;/p&gt;

&lt;p&gt;1:  If b is odd, Galois-add a to the product&lt;/p&gt;

&lt;p&gt;2:  Multiply a by two.&lt;/p&gt;

&lt;p&gt;3:  If a is more than 256, Galois-add 283&lt;/p&gt;

&lt;p&gt;4:  Divide b by two, discarding the remainder&lt;/p&gt;

&lt;p&gt;5:  Repeat until b is 0&lt;/p&gt;

&lt;p&gt;This is simpler, but still far removed from our normal concept of multiplication until we look at &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiplication_algorithm#Peasant_or_binary_multiplication&quot;&gt;Peasant Multiplication&lt;/a&gt;.  Expressed as a series of steps, peasant multiplication is:&lt;/p&gt;

&lt;p&gt;1:  If b is odd, add a to the product&lt;/p&gt;

&lt;p&gt;2:  Multiply a by two&lt;/p&gt;

&lt;p&gt;3:  Divide b by two, discarding the remainder&lt;/p&gt;

&lt;p&gt;4:  Do this until b is 0.&lt;/p&gt;

&lt;p&gt;Using a basic knowledge of bitwise arithmetic, it is clear to see that these two algorithms are the same except for step 3 of the first one.  This is added because in Galois arithmetic, the only numbers &amp;quot;Allowed,&amp;quot; are those in a certain group, and step three is just the procedure for taking a number outside the group and converting it into one inside the group.&lt;/p&gt;

&lt;p&gt;It&amp;#39;s interesting that a modern, CPU-optimized routine from an encryption algorithm is the same thing Egyptian peasants used millennia ago to calculate payment for sheep, but good math is the same everywhere.&lt;/p&gt;

&lt;p&gt;NOTES:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt; In the actual AES algorithm, there are a few extra steps in the Galois addition function.  These serve only to prevent &lt;a href=&quot;https://en.wikipedia.org/wiki/Timing_attack&quot;&gt;Timing Attacks&lt;/a&gt; and are irrelevant to the math discussed here.&lt;/li&gt;
&lt;li&gt; The reason 283 is the Galois group&amp;#39;s defining constant is actually fairly complicated, but it stems from the fact that it is irreducible, which is similar to primality in standard arithmetic.&lt;/li&gt;
&lt;li&gt; Group theory is hard.&lt;/li&gt;
&lt;/ul&gt;
</description>
                                <pubDate>Tue, 21 Jan 2014 00:00:00 -0600</pubDate>
                                <link>http://japesinator.github.io//2014/01/21/bitwise_galois/</link>
                                <guid isPermaLink="true">http://japesinator.github.io//2014/01/21/bitwise_galois/</guid>
                        </item>
                
        </channel>
</rss>
